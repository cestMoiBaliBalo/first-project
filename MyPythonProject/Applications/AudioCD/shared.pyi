from collections.abc import MutableMapping
from contextlib import ContextDecorator
from pathlib import PureWindowsPath
from typing import Any, Callable, Dict, Iterable, Iterator, IO, List, Mapping, Optional, Sequence, Tuple, Union


DFTPATTERN: str = ...


class AudioCDTags(MutableMapping):
    logger = ...  # type: Any
    track_pattern = ...  # type: Any
    def __init__(self) -> None:
        self._encoder: Optional[Any] = ...
        self._otags: Dict[str, Any] = ...
        self._sequence: Optional[str] = ...
        self._step: int = ...
        self._totaltracks_key: Optional[str] = ...
        self._totaldiscs_key: Optional[str] = ...
    def __delitem__(self, key) -> None: ...
    def __getitem__(self, item): ...
    def __setitem__(self, key, value): ...
    def __iter__(self): ...
    def __len__(self) -> int: ...
    def __str__(self) -> str: ...
    @property
    def album(self) -> str: ...
    @property
    def albumartist(self) -> str: ...
    @property
    def albumid(self) -> str: ...
    @property
    def albumsort(self) -> str: ...
    @property
    def albumsortcount(self) -> str: ...
    @property
    def artist(self) -> str: ...
    @property
    def artistsort(self) -> str: ...
    @property
    def artistsort_letter(self) -> str: ...
    @property
    def bonustrack(self) -> str: ...
    @property
    def bootleg(self) -> str: ...
    @property
    def bootlegalbum_city(self) -> str: ...
    @property
    def bootlegalbum_country(self) -> str: ...
    @property
    def bootlegalbum_date(self) -> str: ...
    @property
    def bootlegalbum_day(self) -> Optional[str]: ...
    @property
    def bootlegalbum_month(self) -> Optional[str]: ...
    @property
    def bootlegalbum_provider(self) -> str: ...
    @property
    def bootlegalbum_title(self) -> str: ...
    @property
    def bootlegalbum_tour(self) -> str: ...
    @property
    def bootlegalbum_year(self) -> Optional[str]: ...
    @property
    def bootlegdisc_reference(self) -> str: ...
    @property
    def bootlegtrack_city(self) -> str: ...
    @property
    def bootlegtrack_country(self) -> str: ...
    @property
    def bootlegtrack_date(self) -> str: ...
    @property
    def bootlegtrack_day(self) -> Optional[str]: ...
    @property
    def bootlegtrack_month(self) -> Optional[str]: ...
    @property
    def bootlegtrack_year(self) -> Optional[str]: ...
    @property
    def bootlegtrack_tour(self) -> str: ...
    @property
    def database(self) -> bool: ...
    @property
    def deluxe(self) -> str: ...
    @property
    def discnumber(self) -> str: ...
    @property
    def foldersortcount(self) -> str: ...
    @property
    def genre(self) -> str: ...
    @property
    def incollection(self) -> str: ...
    @property
    def label(self) -> str: ...
    @property
    def livedisc(self) -> str: ...
    @property
    def livetrack(self) -> str: ...
    @property
    def mediaprovider(self) -> str: ...
    @property
    def origtrack(self) -> str: ...
    @origtrack.deleter
    def origtrack(self) -> None: ...
    @property
    def origyear(self) -> str: ...
    @property
    def sample(self) -> bool: ...
    @property
    def sequence(self) -> str: ...
    @property
    def step(self) -> int: ...
    @property
    def titlesort(self) -> str: ...
    @property
    def title(self) -> str: ...
    @property
    def totaldiscs(self) -> str: ...
    @property
    def totaltracks(self) -> str: ...
    @property
    def tracklanguage(self) -> str: ...
    @property
    def tracknumber(self) -> str: ...
    @property
    def upc(self) -> str: ...
    @property
    def year(self) -> str: ...
    @classmethod
    def fromfile(cls, fil: IO, sequence: str, genres: Any, languages: Any, encoders: Any): ...
    @staticmethod
    def checktags(member: str, container: Mapping[str, bool]): ...
    @staticmethod
    def deserialize(fil: str, enc: str = ...) -> Iterator[str]: ...


class CommonAudioCDTags(AudioCDTags):
    logger: Any = ...
    __tags: Mapping[str, bool] = ...
    def __init__(self, sequence, **kwargs: Any) -> None:
        self._encoders: Any = ...
    def __validatetags(self, **kwargs) -> Tuple[bool, str]: ...


class DefaultAudioCDTags(CommonAudioCDTags):
    logger: Any = ...
    __tags: Mapping[str, bool] = ...
    def __init__(self, sequence: str, **kwargs: Any) -> None: ...
    def __validatetags(self, **kwargs) -> Tuple[bool, str]: ...


class LiveAudioCDTags(DefaultAudioCDTags):
    logger: Any = ...
    REX1: Any = ...
    REX2: Any = ...
    DFTCOUNTRY: str = ...
    __tags: Mapping[str, bool] = ...
    def __init__(self, sequence: str, **kwargs: Any) -> None: ...
    def __validatetags(self, **kwargs) -> Tuple[bool, str]: ...


class BootlegAudioCDTags(CommonAudioCDTags):
    logger: Any = ...
    REX1: Any = ...
    REX2: Any = ...
    DFTCOUNTRY: str = ...
    __tags: Mapping[str, bool] = ...
    def __init__(self, sequence: str, **kwargs: Any) -> None: ...
    def __validatetags(self, **kwargs) -> Tuple[bool, str]: ...


class AudioEncoders(object):
    _encoders: Mapping[str, Mapping[str, str]] = ...
    def get_encoder(self, encoder: str) -> Mapping[str, str]: ...
    def get_encoders(self) -> List[str]: ...


class AudioGenres(object):
    _genres: Mapping[str, str] = ...
    def get_genre(self, artistsort: str, *, fallback: str = ...) -> str: ...


class AudioLanguages(object):
    _languages: Mapping[str, str] = ...
    def get_language(self, artistsort: str, *, fallback: str = ...) -> str: ...


class TagsModifier(AudioCDTags):
    logger: Any = ...
    def __init__(self, obj) -> None: ...


class ChangeAlbum(AudioCDTags):
    def __init__(self, obj, template) -> None: ...


class ChangeAlbumArtist(TagsModifier):
    def __init__(self, obj, albumartist: str) -> None: ...


class ChangeEncodedBy(TagsModifier):
    def __init__(self, obj, provider: str) -> None: ...


class ChangeMediaProvider(TagsModifier):
    def __init__(self, obj, provider: str = ...) -> None: ...


class ChangeTotalTracks(TagsModifier):
    def __init__(self, obj, totaltracks: str) -> None: ...


class ChangeTrack(TagsModifier):
    def __init__(self, obj, offset: int) -> None: ...


class RippedTrack(ContextDecorator):
    _environment = ...  # type: Any
    _outputtags = ...  # type: Any
    _tabs = ...  # type: int
    _in_logger = ...  # type: Any
    def __init__(self, rippingprofile: str, file: IO, sequence: str, *decoratingprofiles: str, **kwargs: Any) -> None:
        self._audiotracktags: Optional[AudioCDTags] = ...
        self._decorators: Optional[Tuple[str, ...]] = ...
        self._encoders: Mapping[str, Mapping[str, str]] = ...
        self._genres: Mapping[str, str] = ...
        self._languages: Mapping[str, str] = ...
        self._profile: Optional[str] = ...
        self._intags: Optional[List[Tuple[str, str]]] = ...
        self._sequence: Optional[str] = ...
        self._tags: Optional[IO] = ...
    @property
    def profile(self) -> str: ...
    @profile.setter
    def profile(self, value: str) -> None: ...
    @property
    def decorators(self) -> Tuple[str, ...]: ...
    @decorators.setter
    def decorators(self, value: Tuple[str, ...]) -> None: ...
    @property
    def tags(self) -> IO: ...
    @tags.setter
    def tags(self, value: IO) -> None: ...
    @property
    def sequence(self) -> str: ...
    @sequence.setter
    def sequence(self, value: str) -> None: ...
    @property
    def intags(self) -> List[Tuple[str, str]]: ...
    @property
    def audiotrack(self) -> AudioCDTags: ...
    @staticmethod
    def get_tags(fil: IO) -> Tuple[List[Tuple[str, str]], str, str]: ...
    @staticmethod
    def alter_tags(audiotrack: AudioCDTags, *profiles: str, **kwargs: Any) -> Any: ...
    def __enter__(self) -> RippedTrack: ...
    def __exit__(self, exc_type, exc_val, exc_tb) -> None: ...


def album(track) -> str: ...
def albums(track: DefaultAudioCDTags, *, fil: Optional[str] = ..., encoding: Optional[str] = ..., db: str = ...) -> Iterator[Tuple[str, Sequence[Union[int, str]]]]: ...
def bootlegs(track: BootlegAudioCDTags, *, fil: Optional[str] = ..., encoding: Optional[str] = ..., db: str = ...) -> Iterator[Tuple[str, Sequence[Union[int, str]]]]: ...
def changealbum(obj, template): ...
def changealbumartist(obj, albumartist: str): ...
def changeencodedby(obj, *, provider: str = ...): ...
def changemediaprovider(obj, *, provider: str = ...): ...
def changetotaltracks(obj, totaltracks: str): ...
def changetrack(obj, offset: int): ...
def dump_audiotags_tojson(track: Union[DefaultAudioCDTags, BootlegAudioCDTags],
                          kallable: Callable[[Union[DefaultAudioCDTags, BootlegAudioCDTags], Optional[str], str, str], Iterator[Tuple[str, Sequence[Union[int, str]]]]],
                          *,
                          database: str = ...,
                          jsonfile: Optional[str] = ...,
                          encoding: str = ...) -> None: ...
def dump_mapping_tojson(jsonfile: str, encoding: str = ..., **collection: Any) -> None: ...
def dump_sequence_tojson(jsonfile: str, *collection: Any, encoding: str = ...) -> None: ...
def dump_sequence_toyaml(yamlfile: str, *collection: Any, encoding: str = ...) -> None: ...
def filcontents(fil) -> Iterable[str]: ...
def get_tagsfile(obj) -> str: ...
def load_mapping_fromjson(jsonfile: str, encoding: str = ...) -> Iterable[Any]: ...
def load_sequence_fromjson(jsonfile: str, encoding: str = ...) -> Iterable[Any]: ...
def save_audiotags_sample(profile: str, *, samples: Optional[str] = ..., **kwargs: Any) -> None: ...
def splitfield(*indexes: int): ...
def upsert_audiotags(rippingprofile: str, file: IO, sequence: str, *decoratingprofiles: str, genres: Optional[Any] = ..., languages: Optional[Any] = ..., encoders: Optional[Any] = ..., **kwargs: Any) -> Tuple[int, Optional[AudioCDTags]]: ...
