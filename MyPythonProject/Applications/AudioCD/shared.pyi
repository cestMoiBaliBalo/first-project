import csv
from collections.abc import MutableMapping
from contextlib import ContextDecorator
from typing import Any, Callable, Dict, IO, Iterable, Iterator, List, Mapping, NamedTuple, Optional, Sequence, Tuple, Union

Profile = NamedTuple("Profile", [("exclusions", List[str]),
                                 ("isinstancedfrom", Any)])
MAPPING: Mapping[str, Mapping[str, str]] = ...
PROFILES: Mapping[str, Profile] = ...
REGEX: Any = ...


class CustomDialect(csv.Dialect):
    delimiter: str = ...
    escapechar: str = ...
    doublequote: bool = ...
    quoting: int = ...
    lineterminator: str = ...


class TrackTags(MutableMapping):
    __logger = ...  # type: Any
    _track_pattern = ...  # type: Any
    _Encoder = NamedTuple("Encoder", [("name", str),
                                      ("code", str),
                                      ("folder", str),
                                      ("extension", str)])
    def __init__(self) -> None:
        self._bootlegalbum_date: Optional[str] = ...
        self._bootlegalbum_isodate: Optional[str] = ...
        self._encoder: Optional[Any] = ...
        self._otags: Dict[str, Any] = ...
        self._sequence: Optional[str] = ...
        self._step: int = ...
        self._totaltracks_key: Optional[str] = ...
        self._totaldiscs_key: Optional[str] = ...

    def __delitem__(self, key) -> None: ...

    def __getitem__(self, item) -> str: ...

    def __setitem__(self, key, value): ...

    def __iter__(self) -> Iterator[Tuple[str, str]]: ...

    def __len__(self) -> int: ...

    def __str__(self) -> str: ...

    @property
    def album(self) -> str: ...

    @property
    def albumartist(self) -> str: ...

    @property
    def albumid(self) -> str: ...

    @property
    def albumsort(self) -> str: ...

    @property
    def albumsortcount(self) -> str: ...

    @property
    def artist(self) -> str: ...

    @property
    def artistsort(self) -> str: ...

    @property
    def artistsort_letter(self) -> str: ...

    @property
    def bonustrack(self) -> str: ...

    @property
    def bootlegdisc(self) -> str: ...

    @property
    def bootlegalbum_city(self) -> str: ...

    @property
    def bootlegalbum_country(self) -> str: ...

    @property
    def bootlegalbum_date(self) -> str: ...

    @property
    def bootlegalbum_day(self) -> Optional[str]: ...

    @property
    def bootlegalbum_month(self) -> Optional[str]: ...

    @property
    def bootlegalbum_provider(self) -> str: ...

    @property
    def bootlegalbum_title(self) -> str: ...

    @property
    def bootlegalbum_tour(self) -> str: ...

    @property
    def bootlegalbum_year(self) -> Optional[str]: ...

    @property
    def bootlegdisc_reference(self) -> str: ...

    @property
    def bootlegtrack_city(self) -> str: ...

    @property
    def bootlegtrack_country(self) -> str: ...

    @property
    def bootlegtrack_date(self) -> str: ...

    @property
    def bootlegtrack_day(self) -> Optional[str]: ...

    @property
    def bootlegtrack_month(self) -> Optional[str]: ...

    @property
    def bootlegtrack_year(self) -> Optional[str]: ...

    @property
    def bootlegtrack_tour(self) -> str: ...

    @property
    def database(self) -> bool: ...

    @property
    def deluxe(self) -> str: ...

    @property
    def discnumber(self) -> str: ...

    @property
    def foldersortcount(self) -> str: ...

    @property
    def genre(self) -> str: ...

    @property
    def incollection(self) -> str: ...

    @property
    def label(self) -> str: ...

    @property
    def livedisc(self) -> str: ...

    @property
    def livetrack(self) -> str: ...

    @property
    def mediaprovider(self) -> str: ...

    @property
    def origtrack(self) -> str: ...

    @origtrack.deleter
    def origtrack(self) -> None: ...

    @property
    def origyear(self) -> str: ...

    @property
    def repository(self) -> Optional[int]: ...

    @property
    def sample(self) -> bool: ...

    @property
    def sequence(self) -> str: ...

    @property
    def step(self) -> int: ...

    @property
    def titlesort(self) -> str: ...

    @property
    def title(self) -> str: ...

    @property
    def totaldiscs(self) -> str: ...

    @property
    def totaltracks(self) -> str: ...

    @property
    def tracklanguage(self) -> str: ...

    @property
    def tracknumber(self) -> str: ...

    @property
    def upc(self) -> str: ...

    @property
    def year(self) -> str: ...

    @staticmethod
    def deserialize(fil: str, enc: str = ...) -> Iterator[str]: ...

    @staticmethod
    def get_argument_tags(**kwargs: str) -> Iterator[str]: ...

    @staticmethod
    def get_mandatory_tags(**kwargs: str) -> Iterator[str]: ...


class CommonTrackTags(TrackTags):
    __logger: Any = ...
    __tags: Mapping[str, bool] = ...

    def __init__(self, sequence, **kwargs: Any) -> None:
        self._encoders: Any = ...

    def __validatetags(self, **kwargs: str) -> Tuple[bool, Optional[str]]: ...

    def _setbootlegtags(self, logger: Any) -> None: ...

    @classmethod
    def fromfile(cls, fil: IO[str], sequence: str, genres: Any, languages: Any, encoders: Any): ...


class DefaultTrackTags(CommonTrackTags):
    __logger: Any = ...
    __tags: Mapping[str, bool] = ...
    def __init__(self, sequence: str, **kwargs: Any) -> None: ...


class LiveTrackTags(DefaultTrackTags):
    REX1: Any = ...
    REX2: Any = ...
    DFTCOUNTRY: str = ...
    __logger: Any = ...
    __tags: Mapping[str, bool] = ...
    def __init__(self, sequence: str, **kwargs: Any) -> None: ...


class LiveBootlegTrackTags(CommonTrackTags):
    REX1: Any = ...
    REX2: Any = ...
    DFTCOUNTRY: str = ...
    __logger: Any = ...
    __tags: Mapping[str, bool] = ...
    def __init__(self, sequence: str, **kwargs: Any) -> None: ...


class AudioEncoders(object):
    _encoders: Mapping[str, Mapping[str, str]] = ...
    def get_encoder(self, encoder: str) -> Mapping[str, str]: ...
    def get_encoders(self) -> List[str]: ...


class AudioGenres(object):
    _genres: Mapping[str, str] = ...
    def get_genre(self, artistsort: str, *, fallback: str = ...) -> str: ...


class AudioLanguages(object):
    _languages: Mapping[str, str] = ...
    def get_language(self, artistsort: str, *, fallback: str = ...) -> str: ...


class TagsModifier(TrackTags):
    __logger: Any = ...
    def __init__(self, obj) -> None: ...


class ChangeAlbum(TrackTags):
    def __init__(self, obj, template) -> None: ...


class ChangeAlbumArtist(TagsModifier):
    def __init__(self, obj, albumartist: str) -> None: ...


class ChangeEncodedBy(TagsModifier):
    def __init__(self, obj, provider: str) -> None: ...


class ChangeMediaProvider(TagsModifier):
    def __init__(self, obj) -> None: ...


class ChangeMediaReference(TagsModifier):
    def __init__(self, obj) -> None: ...


class ChangeMediaTitle(TagsModifier):
    def __init__(self, obj) -> None: ...


class ChangeTotalTracks(TagsModifier):
    def __init__(self, obj) -> None: ...


class ChangeTrackNumber(TagsModifier):
    def __init__(self, obj) -> None: ...


class RippedTrack(ContextDecorator):
    _environment = ...  # type: Any
    _logger = ...  # type: Any
    _tabs = ...  # type: int

    def __init__(self, rippingprofile: str, file: IO, sequence: str, *decoratingprofiles: str, **kwargs: Any) -> None:
        self._audiotracktags: Optional[TrackTags] = ...
        self._decorators: Optional[Tuple[str, ...]] = ...
        self._languages: Mapping[str, str] = ...
        self._encoders: Mapping[str, Mapping[str, str]] = ...
        self._sequence: Optional[str] = ...
        self._profile: Optional[str] = ...
        self._intags: Optional[List[Tuple[str, str]]] = ...
        self._genres: Mapping[str, str] = ...
        self._tags: Optional[IO] = ...

    @property
    def audiotrack(self) -> TrackTags: ...

    @property
    def intags(self) -> List[Tuple[str, str]]: ...

    @property
    def decorators(self) -> Tuple[str, ...]: ...

    @decorators.setter
    def decorators(self, value: Tuple[str, ...]) -> None: ...

    @property
    def profile(self) -> str: ...

    @profile.setter
    def profile(self, value: str) -> None: ...

    @property
    def sequence(self) -> str: ...

    @sequence.setter
    def sequence(self, value: str) -> None: ...

    @property
    def tags(self) -> IO: ...

    @tags.setter
    def tags(self, value: IO) -> None: ...

    @staticmethod
    def get_tags(fil: IO) -> Tuple[List[Tuple[str, str]]]: ...

    @staticmethod
    def alter_tags(audiotrack: TrackTags, *profiles: str) -> Any: ...

    def __enter__(self) -> RippedTrack: ...

    def __exit__(self, exc_type, exc_val, exc_tb) -> None: ...


def albums(track: DefaultTrackTags, *, fil: Optional[str] = ..., encoding: Optional[str] = ..., db: str = ...) -> Iterator[Tuple[str, Sequence[Union[int, str]]]]: ...
def bootlegs(track: LiveBootlegTrackTags, *, fil: Optional[str] = ..., encoding: Optional[str] = ..., db: str = ...) -> Iterator[Tuple[str, Sequence[Union[int, str]]]]: ...
def changealbum(obj, template): ...
def changealbumartist(obj, albumartist: str): ...
def changeencodedby(obj, *, provider: str = ...): ...
def changemediaprovider(obj): ...
def changemediareference(obj): ...
def changemediatitle(obj): ...
def changetotaltracks(obj): ...
def changetracknumber(obj): ...
def dump_audiotags_tojson(track: Union[DefaultTrackTags, LiveBootlegTrackTags],
                          kallable: Callable[[Union[DefaultTrackTags, LiveBootlegTrackTags], Optional[str], str, str], Iterator[Tuple[str, Sequence[Union[int, str]]]]],
                          *,
                          database: str = ...,
                          jsonfile: Optional[str] = ...,
                          encoding: str = ...) -> None: ...
def dump_mapping_tojson(jsonfile: str, encoding: str = ..., **collection: Any) -> None: ...
def dump_sequence_tojson(jsonfile: str, *collection: Any, encoding: str = ...) -> None: ...
def dump_sequence_toyaml(yamlfile: str, *collection: Any, encoding: str = ...) -> None: ...
def get_tagsfile(obj) -> str: ...
def load_mapping_fromjson(jsonfile: str, encoding: str = ...) -> Iterable[Any]: ...
def load_sequence_fromjson(jsonfile: str, encoding: str = ...) -> Iterable[Any]: ...
def upsert_audiotags(rippingprofile: str, file: IO, sequence: str, *decoratingprofiles: str, **kwargs: Any) -> Tuple[int, Optional[TrackTags]]: ...
