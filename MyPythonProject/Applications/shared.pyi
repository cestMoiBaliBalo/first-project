import argparse
import logging
import csv
from abc import ABC, abstractmethod
from collections.abc import Sequence
from contextlib import ContextDecorator
from datetime import date, datetime
from dateutil.parser import parserinfo
from pathlib import Path
from string import Template
from typing import Any, Callable, Iterable, Iterator, List, Mapping, Optional, Set, Tuple, Union


APPEND = ...  # type: str
ARECA = ...  # type: str
COPYRIGHT = ...  # type: str
DATABASE = ...  # type: str
DFTDAYREGEX = ...  # type: str
DFTENCODING = ...  # type: str
DFTMONTHREGEX = ...  # ype: str
DFTTIMEZONE = ...  # type: str
DFTYEARREGEX = ...  # type: str
GENRES = ...  # type: List[str]
LOCAL = ...  # type: Any
LOGPATTERN = ...  # type: str
LOOKALBUMSORT = ...  # type: str
TEMP = ...  # type: Path
TEMPLATE1 = ...  # type: str
TEMPLATE2 = ...  # type: str
TEMPLATE3 = ...  # type: str
TEMPLATE4 = ...  # type: str
TEMPLATE5 = ...  # type: str
TEMPLATE6 = ...  # type: str
TEMPLATE7 = ...  # type: str
TESTDATABASE = ...  # type: str
UPCREGEX = ...  # type: str
UTC = ...  # type: Any
UTF8 = ...  # type: Optional[str]
UTF16 = ...  # type: Optional[str]
WRITE = ...  # type: str


class AlternativeChangeRemoteCurrentDirectory(ContextDecorator):
    def __init__(self, ftpobj, directory: str) -> None:
        self._dir: str = ...
        self._ftpobj: Any = ...
        self._cwd: str = ...
    def __enter__(self): ...
    def __exit__(self, *exc) -> None: ...


class ChangeLocalCurrentDirectory(ContextDecorator):
    def __init__(self, directory: Union[str, Path]) -> None: 
        self._dir: str = ...
        self._cwd: str = ...
    def __enter__(self): ...
    def __exit__(self, *exc) -> None: ...


class ChangeRemoteCurrentDirectory(ContextDecorator):
    def __init__(self, ftpobj, directory) -> None:
        self._dir: str = ...
        self._ftpobj: Any = ...
        self._cwd: str = ...
    def __enter__(self): ...
    def __exit__(self, *exc) -> None: ...


class CustomDialect(csv.Dialect):
    delimiter: str = ...
    escapechar: str = ...
    doublequote: bool = ...
    quoting: int = ...
    lineterminator: str = ...


class CustomFormatter(logging.Formatter):
    converter: Any = ...
    default_time_format: str = ...
    default_localizedtime_format: str = ...
    default_format: str = ...
    def formatTime(self, record, datefmt=Optional[str]) -> str: ...


class CustomHandler(logging.StreamHandler):
    def __init__(self, arg, func) -> None: ...


class CustomTemplate(Template):
    delimiter: str = ...
    idpattern: str = ...
    flags: Any = ...
    def __init__(self, template: str) -> None: ...


class Files(Sequence):
    def __init__(self, path: Path, *, excluded: Optional[Callable[[Path, Iterable[str]], Set[Path]]] = ...) -> None:
        self._collection: List[Path] = ...
    def __contains__(self, item) -> bool: ...
    def __getitem__(self, item) -> Path: ...
    def __iter__(self) -> Iterator[Path]: ...
    def __len__(self) -> int: ...
    def __repr__(self) -> str: ...

class GetPath(argparse.Action):
    def __init__(self, option_strings, dest, **kwargs) -> None: ...
    def __call__(self, parsobj, namespace, values, option_string= ...) -> None: ...


class LocalParser(parserinfo):
    MONTHS: List[Tuple[str, str]]
    def __init__(self, dayfirst: bool = ..., yearfirst: bool = ...) -> None: ...


class TemplatingEnvironment(object):
    def __init__(self, path, keep_trailing_newline: bool = ..., trim_blocks: bool = ..., lstrip_blocks: bool = ..., **kwarg: Any) -> None:
        self._environment = ...  # type: Any
    def set_environment(self, **kwargs) -> None: ...
    def get_template(self, template: str): ...


class TitleCaseBaseConverter(ABC):
    config = ...  # type: Mapping[str, Union[List[str], bool]]
    acronyms = ...  # type: Any
    alw_lowercase = ...  # type: Any
    alw_uppercase = ...  # type: Any
    alw_capital = ...  # type: Any
    apostrophe_regex1 = ...  # type: Any
    apostrophe_regex2 = ...  # type: Any
    apostrophe_regex3 = ...  # type: Any
    apostrophe_regex4 = ...  # type: Any
    apostrophe_regex5 = ...  # type: Any
    apostrophe_regex6 = ...  # type: Any
    apostrophe_regex7 = ...  # type: Any
    capitalize_firstword = ...  # type: Any
    capitalize_lastword = ...  # type: Any
    capitalize_secondword = ...  # type: Any
    capitalize_words = ...  # type: Any
    punctuation = ...  # type: Any
    roman_numbers_regex1 = ...  # type: Any
    roman_numbers_regex2 = ...  # type: Any
    roman_numbers_regex3 = ...  # type: Any
    def __init__(self) -> None: ...
    @abstractmethod
    def convert(self, title: str) -> str: ...


class TitleCaseConverter(TitleCaseBaseConverter):
    _logger = ...  # type: Any
    def __init__(self) -> None: ...
    def convert(self, title: str) -> str: ...


class ToBoolean(object):
    def __init__(self, arg) -> None:
        self._bool: bool = ...
    @property
    def boolean_value(self) -> bool: ...


def adjust_datetime(year: int, month: int, day: int, hour: int, minutes: int, seconds: int) -> Optional[datetime]: ...
def booleanify(arg): ...
def convert_timestamp(utc_timestamp: int, tz: Any = ...) -> datetime: ...
def copy(src: str, dst: str, *, size: int = ...) -> str: ...
def customfilehandler(maxbytes: int, backupcount: int, encoding: str = ...): ...
def customfilter(func, record) -> bool: ...
def customformatterfactory(pattern: str = ...): ...
def eq_string_(a: str, b: str, *, sensitive: bool = ...) -> bool: ...
def find_files(directory: Path, *, excluded = Callable[[Path, Iterable[str]], Set[Path]]) -> Iterator[Path]: ...
def format_date(dt: Union[date, datetime], *, template: str = ...) -> str: ...
def get_dirname(path: str, *, level: int = ...) -> str: ...
def get_drives() -> Iterator[str]: ...
def get_nearestmultiple(length: int, *, multiple: int = ...) -> int: ...
def get_readabledate(dt: datetime, *, template: str = ..., tz: Any = ...) -> str: ...
def get_rippingapplication(*, timestamp: Optional[int] = ...) -> Tuple[str, Optional[int]]: ...
def get_tabs(length: int, *, tabsize: int = ...) -> str: ...
def get_utcreadabledate(dt: datetime, *, template: str = ..., tz: Any = ...) -> str: ...
def groupby_(iterable, index: int): ...
def grouper(n: int, *iterables, fillvalue: Optional[Any] = ...): ...
def ljustify(arg: str, width: int, *, char: str = ...) -> str: ...
def localize_date(dt: datetime, tz = ...) -> datetime: ...
def mainscript(strg: str, align: str = ..., fill: str = ..., length: int = ...) -> str: ...
def nested_groupby_(iterable, *args): ...
def normalize(arg: str) -> str: ...
def normalize2(arg: str) -> str: ...
def now(*, template: str = ...) -> str: ...
def partitioner(iterable, *, predicate=...): ...
def pprint_count(*iterables: Tuple[Union[int, str], int], key_gap: int = ..., key_width: Optional[int] = ..., char: Tuple[str, str] = ...) -> Iterator[Tuple[str, str]]: ...
def pprint_mapping(*iterables: Tuple[Union[int, str], Union[int, str]], gap: int = ..., char: str = ..., width: Optional[int] = ...) -> Iterator[Tuple[str, Union[int, str]]]: ...
def pprint_sequence(*items: Union[int, str], align: str = ..., gap: int = ..., char: str = ..., width: Optional[int] = ...) -> Iterator[str]: ...
def rjustify(arg: str, width: int, *, char: str = ...) -> str: ...
def rjustify_index(arg: int, width: int, *, char: str = ...) -> str: ...
def sort_by_insertion(*items: Any, reverse: bool = ...) -> Iterator[Any]: ...
def stringify(arg) -> str: ...
def valid_albumid(albumid: str) -> str: ...
def valid_albumsort(albumsort: str) -> str: ...
def valid_database(database: str) -> str: ...
def valid_datetime(arg) -> Tuple[int, datetime, Tuple[int, int, int, int, int, int, int, int, int, str, int]]: ...
def valid_discnumber(discnumber: Union[int, str]) -> int: ...
def valid_genre(genre: str) -> str: ...
def valid_path(path: str) -> str: ...
def valid_productcode(productcode: str) -> str: ...
def valid_tracks(tracks: Union[int, str]) -> int: ...
def valid_year(year: Union[int, str]) -> int: ...
